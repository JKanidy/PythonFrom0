Объявление функции
def min2(a, b):
    if a <= b:
        return a
    else:
        return b

Наиболее интересен двойной вызов функции для нахождения минимума из 3х чисел
m = min2(min2(32, 41), 44)

Так же можно объявить функцию с произвольным числом параметров:
def min(*a):
    m = a[0]
    for x in a:
        if m > x:
            m = x
    return m
Вызовы:
min(5)
min(5, 30)
min([5, 30, 100, 4]) и тд.


Так же можно объявить функцию со значением параметра по умолчанию:
def min2(a=1, b=1)

С помощью конкретного указания параметра можно указывать их в любом порядке при вызове функции:
m = min2(b = 4, a = 1)

Изменение локальных переменных:
def init_values(a):
    a = 100

b = 0
init_values(b)
print(b) #Вывод: 0

Но это не работает с переменными, которые являются изменяемыми, например со списками:
def append_zero(xs):
    xs.append(0)

a = []
append_zero(a)
print(a) #Вывод: [0]

При этом, список a просто связывается со списком xs, это работает например при добавлении в список какого-либо значения,
однако если создать новую связь, например привязать а к списку = [100], то связь xs со списком [0] пропадает
def append_zero(xs):
    xs.append(0)
    xs = [100]

a = []
append_zero(a)
print(a) #Вывод: [0]

-----------------------------------------Глобальные переменные----------------------------------------------------------
def print_value():
    print(a)

a = 5
print_value() #Вывод: 5

Однако:
def print_value():
    print(a)
    a = 10
    print(a)

a = 5
print_value() #Вывод: Ошибка: UnboundLocalError, тк мы попытались изменить значение переменной внутри функции и поэтому
она стала считаться локальной и поэтому в первом print'е мы пытаемся вывести переменную, которая ещё не объявлена

------------------------------------------Множества---------------------------------------------------------------------
Создание пустого множества:
s = set()
Инициализация со значениями:
s = {'orange', 'juice'}
print('orange' in s) #Вывод: True

Операции с множествами:
s.add(element) - добавление
s.remove(element) - удаление элемента, если такой есть, но в противном случае возникнет ошибка
s.discard(element) - удаление элемента вне зависимости, есть такой элемент или нет
s.clear - удаление всех жлементов множества

При переборе элементов множества с помощью for:
    for x in s:
        print(x)
Будут выведены все элементы, за исключением повторяющихся, при этом порядок элементов нарушается

s = {'orange', 'juice', 'cat', 'dog', 'orange', 'juice', 'house'}
for i in range(len(s)):
    print(s[i]) #Вызовет ошибку

---------------------------------------------Словари--------------------------------------------------------------------
Пара ключ-значение, инициализация происходит с помощью dict() или {}. Словари являются ИЗМЕНЯЕМЫМ типом данных, не имеют
порядка, все ключи различны (тоесть если добавить значение по уже существующему ключу, то стаоре значение будет стерто),
ключами могут быть неизменяемые элементы (числа, строки, но не могут быть словари). Так же значениями могут быть списки

a = {'b':10, 12: 1000}
print(a['b']) #Вывод: 10

Операции со словарями:
key in dictionary, key not in dictionary - True, False
dictionary[key] = value, добавление в словарь значения по ключу
dictionary.get(key) - вернет значение если ключ есть, но если его не будет вернёт None вместо ошибки
del dictionary[key] - ударение, причем будет удалена вся пара ключ-значение

Перебор элементов словаря:
d = {'C': 14, 'A': 12, 'T': 9, 'G': 18}
for key in d:
    print(key, end='') #GCAT

for key in d.keys():
    print(key, end='') #GCAT

for value in d.values():
    print(value, end='') #18 14 12 9

for key, value in d.items():
    print(key, value, end='') #G 18; C 14; A 12; T 9


--------------------------------------------Файловый ввод/вывод---------------------------------------------------------
Есть и другой способ открытия файла, но тогда придется самостоятельно закрывать подключение:
with open('file.txt', 'r') as inf:
    s1 = inf.readline()
    s2 = inf.readline()

То же самое и с записью в файл, только используем 'w' и тут надо явно указывать переход на след. строку:
with open('file.txt', 'w') as inf:
    inf.write('Hello \n')
    inf.write(str(25))


Полезные функции:
s = inf.readline().strip() - убирает все служебные символы

os.path.join('.', 'dirname', 'filename.txt') - построение полного пути к файлу - '.\dirname\filename.txt'

Построчное чтение файла:
with open('file.txt', 'r') as file:
    for line in file:
        line = line.strip()
        print(line)

